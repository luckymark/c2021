# 课上的作业/练习总结



## Level 1 08 递归 HANOI问题

- 一种美妙的函数处理方式
- 以哈诺塔为例子：
  1. 声明函数HANOI(检查处理几个饼，int X；从1柱子，char A；经过2柱子，char B；到3柱子，char C)
  2. HANOI=(A→B，x=1；or 递归 )
  3. 递归中：X-1个饼A到B （HANOI），A到C，X-1个饼B到C

- 先调用，后返回（记住了调用的地址，能够准确返回）
- 编译器可能会将其优化，变成循环的逻辑（伪递归）



## Level 1 queue 堆栈

### 先进先出

- add 将值排到队列最后
- pop 将队列头调出

### 先进后出

- pop 将队列尾调出

### 逆波兰

- 用先进后出的模式
- if(strcmp(button,"+")==0） 判断键入是否是符号
  - button需要是一个字符串类型
  - 主义char【】格式默认尾巴有个0
  - 长度赋予2
- atoi 函数： aoti(char a)， 会将a中数字提取出，返回一个int类型的整数
- 逆波兰原理：来数字扔到队伍最后，来符号处理队伍最后两个数字，来等于号输出队列第一个数字

## Level 1 单链表





# C 菜鸟教程

## 1.1 程序结构

C程序由以下要素组成（底层原理）：

- 预处理器指令：#include<stdio.h>
- 函数:int main()[主函数]，void add(int a, int b)，printf……
- 变量:int a，char b，int*a
- 语句 & 表达式:函数与变量的组合
- 注释：//……  /* …… */ 

无非就这些吗？



## 1.2 基本语法

### C 的令牌（Token）

C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。

- 分号：在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束
- 注释：C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。
  - 一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。
  - C 标识符内不允许出现标点字符，比如 @、$ 和 %。
  - C 是**区分大小写**的编程语言。

- 关键字：关键字不能作为常量名、变量名或其他标识符名称。

- C 中的空格：只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。
  - 在 C 中，空格用于描述空白符、制表符、换行符和注释。
  - 空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。
  - 为了增强可读性，可以根据需要适当增加一些空格。



## 1.3 数据类型

1. **基本类型：**它们是算术类型，包括两种类型：整数类型和浮点类型
2. **枚举类型：**它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。（常量）
3. **void 类型：**类型说明符 *void* 表明没有可用的值。
4. **派生类型：**它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。

### 整数类型

| 类型           | 存储大小    | 值范围                                               |
| :------------- | :---------- | :--------------------------------------------------- |
| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |

- 为了得到某个类型或某个变量在特定平台上的准确大小，可以使用 **sizeof** 运算符。
- ⭐表达式 *sizeof(type)* 得到对象或类型的存储字节大小。

### 浮点类型

下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：

| 类型        | 存储大小 | 值范围                 | 精度      |
| :---------- | :------- | :--------------------- | :-------- |
| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位小数  |
| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位小数 |
| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位小数 |

### void 类型

void 类型指定没有可用的值。它通常用于以下三种情况下：

| 序号 | 类型与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **函数返回为空** C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 **void exit (int status);** |
| 2    | **函数参数为空** C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 **int rand(void);** |
| 3    | **指针指向 void** 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 **void \*malloc( size_t size );** 返回指向 void 的指针，可以转换为任何数据类型。 |

- ⭐如果现在您还是无法完全理解 void 类型，不用太担心，在后续的章节中我们将会详细讲解这些概念。



## 1.4 变量

- ⭐ **变量其实只不过是程序可操作的存储区的名称。**存储区域！存储区域！存储区域！
  - C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中。
  - 运算符可应用于变量上。

- 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。

| 类型   | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| char   | 通常是一个字节（八位）, 这是一个整数类型。                   |
| int    | 整型，4 个字节，取值范围 -2147483648 到 2147483647。         |
| float  | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png) |
| double | 双精度浮点值。双精度是1位符号，11位指数，52位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png) |
| void   | 表示类型的缺失。                                             |

- 不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。



### C 中的变量声明

变量声明**向编译器保证**变量（”声明“的作用）以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

变量的声明有两种情况：

- 1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
- 2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。
- 除非有extern关键字，否则都是变量的定义。

### C 中的左值和右值

C 中有两种类型的表达式：

1. **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。

2. **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

   

## 1.5 常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。

**常量**就像是常规的变量，只不过常量的值在定义后不能进行修改。



### 整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：

- 0x 或 0X 表示十六进制
- 0 表示八进制
- 不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数(long)。



### 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。

当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。



### 字符常量

字符常量是括在单引号中，例如，'x' 可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

⭐在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义

| 转义序列   | 含义                       |
| :--------- | :------------------------- |
| \\         | \ 字符                     |
| \'         | ' 字符                     |
| \"         | " 字符                     |
| \?         | ? 字符                     |
| \a         | 警报铃声                   |
| \b         | 退格键                     |
| \f         | 换页符                     |
| \n         | 换行符                     |
| \r         | 回车                       |
| \t         | 水平制表符                 |
| \v         | 垂直制表符                 |
| \ooo       | 一到三位的八进制数         |
| \xhh . . . | 一个或多个数字的十六进制数 |



### 字符串常量

字符串字面值或常量是括在双引号 "" 中的。

一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用空格做分隔符，把一个很长的字符串常量进行分行。



### 定义常量

在 C 中，有两种简单的定义常量的方式：

1. 使用 **#define** 预处理器。define identifier value；
2. 使用 **const** 关键字。const type variable = value;

## 1.6 存储类

存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：

### auto

- 所有**局部变量**默认的存储类

### register

- 存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。
- 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

### static

- **static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以**在函数调用之间保持局部变量的值。**

- void func1(void) {

  static int thingy=5;  

  thingy++;  

  }

- 在上述例子中，thingy只会初始化一次，也就是说每次thingy++后的thingy++值都会被保留，不会因为函数再次被调用而被初始化

### extern

- **extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。
- 可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。

## 1.7 运算符

运算符是一种告诉编译器执行特定的**数学或逻辑操作**的符号。C 语言内提供了以下类型的运算符：

***假设A=10，B=20***

### 算术运算符

| /    | 分子除以分母             | B / A 将得到 2 |
| ---- | ------------------------ | -------------- |
| %    | 取模运算符，整除后的余数 | B % A 将得到 0 |
| ++   | 自增运算符，整数值增加 1 | A++ 将得到 11  |
| --   | 自减运算符，整数值减少 1 | A-- 将得到 9   |

### 关系运算符

| 运算符 | 描述                                                         | 实例            |
| :----- | :----------------------------------------------------------- | :-------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 为假。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。 |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 为假。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。  |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 为假。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。 |

### 逻辑运算符

| 运算符 | 描述                                                         | 实例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| &&     | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。         | (1&& 0) 为假。    |
| \|\|   | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (1 \|\| 0) 为真。 |
| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(1 && 0) 为真。  |

### 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

| ~    | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2;    ~0=1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| <<   | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>   | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

### 赋值运算符

| 运算符 | 描述                                                         | 实例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |

### 杂项运算符

| 运算符   | 描述             | 实例                                 |
| :------- | :--------------- | :----------------------------------- |
| sizeof() | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。  |
| &        | 返回变量的地址。 | &a; 将给出变量的实际地址。           |
| *        | 指向一个变量。   | *a; 将指向一个变量。                 |
| ? :      | 条件表达式       | 如果条件为真 ? 则值为 X : 否则值为 Y |

## 1.8 判断

### ? : 运算符(三元运算符)

- 我们已经在前面的章节中讲解了 **条件运算符 ? :**，可以用来替代 **if...else** 语句。它的一般形式如下：

```
Exp1 ? Exp2 : Exp3;
```

- 其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。

- ? 表达式的值是由 Exp1 决定的。

- **如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值。**





# ”杂谈“



## inline？

- 内敛函数

- 将函数拷贝到位置使用

- 逻辑与普通函数一致

- 加在函数声明前

  

## 取名的艺术

- 上帝编程：先想一个函数干嘛的，取名字，再编写内部逻辑
- 取名清楚，代码清晰，编写轻松



## 指针

int * p

- 一个指针，指向p的地址
- =&x 初始化符号，令其指向x
- *p: 简引用，取他指向的东西
- p++：让指针指的东西指向下一个（改变p，改变指向的地址）
- 不允许指针＋指针（没有意义）
- 指针减指针：有点意义，意味着他们隔多少
- p1 == p2: 指向同一个东西
- p1 = p2：令他们指向一个东西
- 数组↔指针
- 动态分配：int * a = (int *) malloc (100 * sizeof(int) );
  - 借了要还：free(a)
  - 记得重看网课

- 野指针：很危险 free完的指针
  - 在free后接一个a = NULL                                  