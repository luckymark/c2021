## 字符串函数

![image-20210228093713845](https://gitee.com/learnerLj/typora/raw/master/img/image-20210228093713845.png)



## 全局变量与局部变量

#### 特点：

- 程序块之外的算全局变量，但是有先后识别顺序。
- 全局变量适合直接传参，但是程序运行的时候都占内存，而且每一部分具有依赖性，迁移性差。

- 大量的全局变量使得牵扯太多，可读性差。

#### extern标识符：

- extern 外部变量声明（要区分定义和声明），可以忽视读取先后顺序。

```C
extern int a,b;
//这里不分配内存，是标志着后面会定义，定义的时候分内存。
```

- extern在局部中声明，只对这一部分的代码块有效。

- 如何和代码块的局部变量重名，那么这个代码块不影响这个全局变量，按照里面的局部变量处理。
- **全局变量跨文件引用**，默认是不支持的，但是可以在本文件里声明了 extern后，就不会分配内存，可以引用了。（注意，这样交叉使用，可读性会很差）

## 变量的存储和使用

#### 静态存储方式和动态存储方式

**静态存储方式**：分配固定存储空间。

全局变量放在静态存储区，程序结束后才释放。



**动态存储方式**：根据需要动态发分配存储空间。

形式参数、局部变量和函数的返回值以及被调用时的值存储在动态存储区。

#### static 设置局部静态变量

一般而言函数或者程序块调用完了，内存就会销毁。但是设置 static 声明局部静态变量，保存下载原来的内存，而且只在编译时赋值一次。如果局部静态变量不赋初值，那么默认为0。

**注意：如果用在全局变量之前，表示只能在本文件中调用**

```C
#include <stdio.h>
void functest() {
	static int c;
	printf("%d\n", c);
	c++;
	return;
}

int main() {
	functest();
	functest();
	functest();
	functest();
}
```

注意它仍然时局部变量，其他的程序块不能引用。而且，声明了之后static 就不能跨文件引用了

#### 外部函数和内部函数

标准是能否被其他源文件调用。

内部函数：只能在本文件里使用。只需要在函数前面加上static，因此也被称为**静态函数**。

外部函数：不用static就是外部函数。默认支持函数跨文件引用。也有在前面加extern来声明的，但是着不必要。只需要在前面加函数声明即可。

## 宏

#### 不带参数的宏定义

```C
//格式：#define 宏的名字 字符串 
#define PI 3.14151926
//好处是用简单的名字代替复杂的字符串，在修改的时候非常好用，也提高了可移植性。
//在编译的时候替换的过程，就叫做宏展开。
#undef PI
//用于终止宏定义，后面的不能再使用PI
```

说明：

1. 宏名一般用大写字母，这是习惯
2. 不是C语句，不要加分号，否则分号会被一起替换
3. 不能跨文件使用。
4. 宏定义中可以使用其他宏。
5. 双引号（字符串）内的宏名不替换，

#### 带参数的宏定义

```C
//格式：#define 宏的名字(参数表) 字符串
#define S(a,b) a*b
```

1. 只是替换，不会做其他处理。

   ```
   S(1+5,2+3) 表示 1+5*2+3，计算结果不是原来的求积
   所以常常加括号处理，#define S(a,b) (a)*(b)
   ```

2. 复杂语句中有时候使用多行语句进行宏代替

   ```C
   #define PRASE do{\
   printf("test/n");\
   }while(0)
   ```

3. 宏展开是在编译时进行的，展开时不分配内存，也没有返回值这种说法，也没有值传递的说法。

4. 宏替换只占用编译时间，不占用运行时间。而函数调用占的是运行时间(分配内存，传递参数，执行函数体，返回值) ;

## 文件包含

本质上：**将另外文件中的代码包含在这个文件中**

格式：#include “文件名”                                                         	其中文件名常常为 .h 文件，叫做头文件

1. 一个include 只能包含一个文件。
2. 可以嵌套包含。一个头文件中，还能包含其他头文件。
3. 方便使用现成的代码，也方便公共修改。
4. <>表示到系统目录找文件，“ ”表示首先在当前目录查找，找不到再到系统目录找。

## 条件编译

格式：

```c
//方式一
#ifdef 标识符 //如果定义过这个标识符，则执行这一段。
程序段
#else
程序段
#endif
//方式二
#ifndef 标识符 //如果没有定义过这个标识符，则执行这一段。
程序段
#else
程序段
#endif   
//方式三
#if 表达式 //如果表达式为真，则执行这一段。
程序段
#elif 表达式
程序段
#else
程序段
#endif   
```

优点：

1. 编译的时候只剩下满足条件的那一块，可以减少文件长度。
2. 跨平台时，条件编译时预设好不同平台需要编译的代码。

## 指针

**指针非常重要！**

#### 前提知识

1. 变量可能保存在不同的存储区，比如静态存储区、动态存储区等。
2. 变量分配内存的时间不同，有些事编译的时候分配内存，有些则是运行时分配。
3. 每种数据类型都会占用内存。例如 int, char, float等，可以用 sizeof(类型)查看。 

#### 地址的概念

计算机中用十六进制的数来表示地址，0x开头，表示十六进制。

**严格区分地址和地址代表的内容。**一个地址代表一个字节，但是我们以第一个占用的地址为这个变量对应的地址。程序内部维持一张表，记录着地址和变量名的对应关系。

#### 直接访问和间接访问

直接访问：按地址取址，直接从地址中存取变量。

间接访问：将变量的地址存放在另一个内存单元中，即一种特殊变量来存储地址。例如：p=&a，&是地址符号。这就是p的地址指向了a的地址，而P的地址一般使用四个字节的内存，里面储存着a的地址。

读取的过程：

1. 先找到存放p的地址，然后从p的地址中取出i的地址。
2. 然后从a的地址中找到存储的内容。
3. 通过映射表来把存储的内容映射成a.

我们就说像上面p那样，专门存放另外一个变量的地址的变量，就叫做**指针变量**。指针（地址）的值就是指向的变量的地址。

#### 指针变量

格式：类型标识符号 *指针变量名

```c
int i,j;
float k;
int *mypoint1,*mypiont2; //int 类型变量表示，我们要指向的是一个整型变量，不能指向浮点型的k。
float *mypoint3; //表示指向浮点数类型的指针变量。
//给指针变量赋值
mypoint1=&i;
mypoint3=&k;
```

1. 定义指针变量的时候要加`*`，但是使用的时候不加`*`，指针变量名是不含`*`的。
2. 指针变量只能指向同一类型的变量。
3. 指针变量只存地址，不要乱赋值。

**运算符：**&：取地址运算符。

*：间接访问运算符。

**如果不是定义指针变量或者当作乘法运算，\*指针变量名 表示所指向的变量**

注意事项：*p=a

1. &\*p。因为指针运算符和乘法运算符的优先级相同，而且是**从右至左**结合。所以相当于&(*p)，即p指向的变量的地址，相当于p。
2. *&a。&a表示a的地址，也就是p的值，而\*p即指向的变量，相当于a。
3. (\*p)++。相当于a++。
4. \*p++。因为++和\*的优先级相同，而且是从右到左运算，所以等价于\*(p++)，而指针变量加一，代表跳过存储这一块内存占用的地址，到下一块内存。比如 int 类型占用4个字节，那个p++的值加4.**但是，在引用的时候，\*p++ 是先用后加，返回值是\*p，然后p++**
5. *++p。先加后用，返回值是\*(p+1).

**指针赋值代表指向传递**



## 数组的指针和指向数组的指针

#### 特点

- 数组里面的元素的地址是相连的。

- 数组的地址是第一个元素的地址。
- 数组名就代表数组地址。

#### 定义指针变量并赋初值

```c
int *p=&a[0];
//等价于
int *p=a;
//等价于
int *p;
p=&a[0];
```

#### 通过指针引用数组元素

```c
//第一类,赋值
*p=19;

//第二类，访问下一个内存单元
p=p+1;

//第三类，访问特定元素地址
//p+i或a+i 指的是a[i]的地址

//第四类，访问特定元素的值
//*(p+i)或者*(a+i) 指a[i]

//第五类，访问特定元素的值
//p[i]与*(p+i)等价，即a[i]
```

**a[i]，p[i]，*(P+i)，\*(a+i)，都代表引用数组元素。**

```c
#include<stdio.h>
int main() {
	int a[5] = { 12,14,20,18,50 };
	int* p;
	int i;

	for (i = 0; i < 5; i++) {
		printf("%d\n", a[i]);
	}
	printf("------------------------------------\n");
	for (i = 0; i < 5; i++) {
		printf("%d\n", *(a+i));
	}
    //效率最高
	printf("------------------------------------\n");
	for (p = a; p<a+5; p++) {
		printf("%d\n", *p);
	}
```

实际上，系统中是根据a[i]，推算*(a+i)，所以通过指针来引用，效率是比较高的。

注意

- 数组首地址不能更改。a++不合法。
- 不要动自己未定义的内存。

#### 数组作为函数参数

##### 1. 实参形参都是数组名，那么函数就可以改变实参数组的值

```c
#include<stdio.h>
void changeValue(int ba[]) {
	ba[3] = 27;
	ba[4] = 45;
	return;
}
int main() {

	int a[5] = { 85,70,98,92,78 };
	printf("%d %d %d %d %d\n",a[0],a[1],a[2],a[3],a[4]);
		changeValue(a);
	printf("%d %d %d %d %d\n", a[0], a[1], a[2], a[3], a[4]);
	printf("断点");
}
```

其中，a,ba公用同一段内存，指的是同一个数组。

##### 2. 实参是数组名，形参是指针。

这时赋值时和两者都是数组名，几乎一样。

##### 3. 实参和形参都是指针变量

这时赋值时和两者都是数组名，几乎一样。

##### 4. 实参为指针，实参为数组名

```c
#include<stdio.h>
void changeValue(int ba[]) {
	ba[3] = 27;
	ba[4] = 45;
	return;
}
int main() {

	int a[5] = { 85,70,98,92,78 };
	int *pa = a;
	printf("%d %d %d %d %d\n",a[0],a[1],a[2],a[3],a[4]);
		changeValue(pa);
	printf("%d %d %d %d %d\n", a[0], a[1], a[2], a[3], a[4]);
```

这几种方法很类似，指针数组作为参数传入，也会被当作数组。

#### 多维数组

多维数组在内存中是连续存放的，注意顺序，a\[3]\[3][4],从右边开始变，且递增。下边这样变化，000，001，002，003，010 ....213,213,220,221,222,223。

![image-20210307133540210](https://gitee.com/learnerLj/typora/raw/master/img/20210307133540.png)

注意：

1. a+i,指的是a[i]行的内容。
2. a[0]，代表的是地址，即a[0]=&a[0]\[0].
3. a[0]+1，代表在a[0]这一行，a[0]\[1]的地址，即a[0]+1=&a[0]\[1].
4. *a=a=a[0]，所以 a[0]+1=\*a +1.
5. \*(a+1)+2，指第一行第二列的地址。

**总之，二维数组的地址是地址指向地址，一层一层嵌套，\*表示进入当前这一层嵌套，a[]也表示进入了这一层的嵌套。**

#### 指针数组

```c
#include<stdio.h>
int main() {
	int *p[4];
	int a[3][4];
	int i, j;
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 4; j++) {
			a[i][j] = 86;
		}
	}
	p[0] = &a[0][0];
	p[1] = &a[0][1];
	p[2] = &a[0][2];
	p[3] = &a[0][3];

	for (j = 0; j < 4; j++) {
		printf("%d\n", *p[j]);
	}
	printf("断点");
}
```

#### 数组指针

```c
#include<stdio.h>
int main() {
	int(*p)[10];  //长度为10个整型的一个地址，这样方便递增改变地址。
	int a[10];
	int i;
	for (i = 0; i < 10; i++) {
		a[i] = i;
	}
	p = &a; //一维数组需要有寻址符号。
	int *q;
	q = (int*)p;
	for (i = 0; i < 10; i++) {
		printf("value = %d\n", *q);
		q++;
	}
}
```

```c
#include<stdio.h>
int main() {
	int(*p)[10];
	int a[3][10];
	int i, j;
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 10; j++) {
			a[i][j] = i + j;
		}
	}
	p = a;
	int *q;
	q = (int*)p;
	for (i = 0; i < 3; i++) {
		q = *(p + i);
		for (j = 0; j < 10; j++) {
			printf("%d	", *q);
			q++;
		}
		printf("\n");
	}
    //这一段循环也可以这样写
    //for (i = 0; i < 3; i++) {
	//	q = *(p + i);
	//	for (j = 0; j < 10; j++) {
	//		printf("%d	", *(*(p+i)+j));
	//		q++;
	//	}
	//	printf("\n");
	//}
}
```

## 字符串的指针

#### 字符串的表现形式

```c
#include<stdio.h>
int main() {
	char str1[] = "I love you!";
	printf("%s\n", str1);
}
```

#### 字符数组的指针规律不变

因为字符数组实际上是转码后拷贝到`str1[]`，分配不同的内存，和数字的数组是一致的。

#### 常量的字符指针

因为内存中有一段类似字符数组的东西存放字符串常量，所以 **指向同一个字符串常量的指针是相同的**

这样很方便灵活的修改。

```c
#include <stdio.h>
#include <windows.h>
int main() {
	char a[1000];
	int i, n = 0,d=1;
	int N = 10;
	while (1) {
			for (i = 0; i < n; i++) {
				*(a + i) = ' ';
			}
			*(a + i) = 'A';
			*(a + i + 1) = '\0';
			printf("%s", a);
			system("cls");
			n += d;
			if (n == N||n==0) {
				d = -d;
			}
	}
}
```

#### 字符指针做函数参数

```c
#include<stdio.h>
void copystr(char *from, char *to) {
	int i;
	for (i = 0; from[i] != '\0'; i++) {
		to[i] = from[i];
	}
    	
	/*while (*from) {
		*to++ = *from++;
	}*/
    
	to[i] = '\0';
}
int main() {
	char a[] = "this is source content.";
	char b[100];
	copystr(a, b);
	printf("%s\n", a);
	printf("%s\n", b);
}
```

**注意：\*p=a，那么p[i]=a[i]**

#### 区分字符指针与字符数组

1. 字符数组是由若干个元素组成，每个元素中存放一个字符；字符指针存放的事字符串的首地址，不存放内容。
2. **赋值方式的差别：**初始化字符数组时，是把常量拷贝给字符数组。字符指针初始化时，是把指针指向常量的地址。
3. 字符数组的地址不可以更改，但是字符指针可以再次定义指针的指向。

## 函数指针








